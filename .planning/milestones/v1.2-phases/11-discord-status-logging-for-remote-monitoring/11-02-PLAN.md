---
phase: 11-discord-status-logging-for-remote-monitoring
plan: 02
type: execute
wave: 2
depends_on:
  - "11-01"
files_modified:
  - src/providers/discord_bot.py
  - src/config.py
  - src/main.py
  - .env.example
autonomous: false
requirements:
  - MON-01
  - MON-04
  - MON-05
  - MON-06

must_haves:
  truths:
    - "Startup embed arrives in Discord monitoring channel when application starts"
    - "User can type 'status' in monitoring channel and receive a health snapshot embed"
    - "If DISCORD_MONITOR_CHANNEL_ID is not set, app runs identically to before -- zero monitoring overhead"
    - "Existing display-message channel behavior is completely unchanged"
    - "Error and recovery embeds flow from main loop through HealthTracker to Discord during API failures"
  artifacts:
    - path: "src/providers/discord_bot.py"
      provides: "Extended bot with monitoring channel support, client/loop exposure, status command"
      contains: "monitor_channel_id"
    - path: "src/config.py"
      provides: "DISCORD_MONITOR_CHANNEL_ID env var"
      contains: "DISCORD_MONITOR_CHANNEL_ID"
    - path: "src/main.py"
      provides: "HealthTracker integration in main loop"
      contains: "health_tracker"
    - path: ".env.example"
      provides: "Documentation of new DISCORD_MONITOR_CHANNEL_ID var"
      contains: "DISCORD_MONITOR_CHANNEL_ID"
  key_links:
    - from: "src/main.py"
      to: "src/providers/discord_monitor.py"
      via: "HealthTracker.record_success/record_failure calls"
      pattern: "health_tracker\\.record_(success|failure)"
    - from: "src/providers/discord_bot.py"
      to: "src/providers/discord_monitor.py"
      via: "MonitorBridge creation in on_ready, status command"
      pattern: "MonitorBridge"
    - from: "src/main.py"
      to: "src/providers/discord_bot.py"
      via: "start_discord_bot returns MonitorBridge"
      pattern: "monitor_bridge"
---

<objective>
Wire the monitoring module into the existing Discord bot and main loop. Extend the bot to support the monitoring channel (status command, startup embed on ready), add DISCORD_MONITOR_CHANNEL_ID config, and integrate HealthTracker into the main loop's fetch cycles.

Purpose: Connect the isolated monitoring logic (Plan 01) to the live application. After this, the system will automatically send alerts on sustained failures and recoveries, and respond to on-demand status queries.

Output: Modified `src/providers/discord_bot.py`, `src/config.py`, `src/main.py`, `.env.example`
</objective>

<execution_context>
@/Users/jdl/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-discord-status-logging-for-remote-monitoring/11-CONTEXT.md
@.planning/phases/11-discord-status-logging-for-remote-monitoring/11-RESEARCH.md
@.planning/phases/11-discord-status-logging-for-remote-monitoring/11-01-SUMMARY.md
@src/providers/discord_bot.py
@src/providers/discord_monitor.py
@src/config.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Discord bot for monitoring channel and add config</name>
  <files>
    src/providers/discord_bot.py
    src/config.py
    .env.example
  </files>
  <action>
**src/config.py changes:**
Add `DISCORD_MONITOR_CHANNEL_ID = os.environ.get("DISCORD_MONITOR_CHANNEL_ID")` next to the existing DISCORD_BOT_TOKEN and DISCORD_CHANNEL_ID lines in the Discord section.

**.env.example changes:**
Add under the existing Discord bot section:
```
# Discord monitoring channel for remote health alerts (optional)
# Sends error/recovery embeds -- silence means healthy
# DISCORD_MONITOR_CHANNEL_ID=123456789012345678
```

**src/providers/discord_bot.py changes:**

1. Update `run_discord_bot()` signature to accept additional parameters:
   - `monitor_channel_id: int | None = None` -- the monitoring channel ID
   - `health_tracker` parameter (from discord_monitor) -- needed for status command
   - `on_ready_callback` -- a callable that receives the client when bot is ready

2. In the `on_ready` event handler:
   - Call `on_ready_callback(client)` if provided -- this lets main.py create the MonitorBridge once the bot's event loop is available.
   - Log that the bot is ready.

3. Extend the `on_message` handler:
   - Keep ALL existing display-channel logic exactly as-is (channel_id check, message bridge, reactions).
   - Add a NEW block: if `monitor_channel_id` is set and `message.channel.id == monitor_channel_id`:
     - If content is "status" (case-insensitive), build and send a status embed using `status_embed()` from discord_monitor.py and the health_tracker's `get_status()` and `uptime_s`.
     - React with checkmark on status command.
   - The two channel blocks are independent if/if (not elif) -- a channel should never be both, but defensive coding.

4. Update `start_discord_bot()`:
   - Accept new parameters: `monitor_channel_id: str | None`, `on_ready_callback: callable | None = None`, `health_tracker = None`.
   - Pass them through to `run_discord_bot()`.
   - Return type stays `MessageBridge | None` (unchanged).
   - The function should still return None if token or display channel_id is not provided. Monitoring is piggybacked on the same bot -- if the bot doesn't start, monitoring doesn't either.

**CRITICAL: Existing display-message behavior MUST be byte-for-byte identical.** The monitoring support is purely additive. Do NOT change the MessageBridge class, the sanitize_for_bdf function, or the display channel message handling logic.
  </action>
  <verify>
    <automated>cd /Users/jdl/Documents/GitHub/divoom-hub && python -m pytest tests/test_discord_bot.py -v && python -c "from src.config import DISCORD_MONITOR_CHANNEL_ID; print('Config import OK')"</automated>
    <manual>Verify .env.example has the new DISCORD_MONITOR_CHANNEL_ID entry</manual>
  </verify>
  <done>discord_bot.py extended with monitoring channel support and status command. config.py has DISCORD_MONITOR_CHANNEL_ID. .env.example documents the new var. All existing discord_bot tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate HealthTracker into main loop with startup/shutdown embeds</name>
  <files>src/main.py</files>
  <action>
**Import additions at top of main.py:**
- `from src.config import DISCORD_MONITOR_CHANNEL_ID`
- `from src.providers.discord_monitor import HealthTracker, MonitorBridge, startup_embed, shutdown_embed`

**In `main()` function:**

1. After `start_discord_bot()` call, set up monitoring:
   - Create a `monitor_bridge` variable initialized to None.
   - Create a `health_tracker = HealthTracker(monitor=None)` initially (MonitorBridge not yet available).
   - Define `on_ready_callback(client)` that:
     a. Creates `MonitorBridge(client, int(DISCORD_MONITOR_CHANNEL_ID))` if DISCORD_MONITOR_CHANNEL_ID is set.
     b. Updates `health_tracker._monitor = monitor_bridge` (set the bridge once bot is ready).
     c. Sends startup embed via `monitor_bridge.send_embed(startup_embed(...))` with config values (DEVICE_IP, bus quay IDs, weather lat/lon).
     d. Logs that monitoring is active.
   - Pass `on_ready_callback`, `monitor_channel_id=DISCORD_MONITOR_CHANNEL_ID`, and `health_tracker` to `start_discord_bot()`.
   - If DISCORD_MONITOR_CHANNEL_ID is not set, log that monitoring is not configured and skip the callback setup.

2. Pass `health_tracker` to `main_loop()`.

3. In the `KeyboardInterrupt` handler (the `except` block in `main()`):
   - Attempt to send shutdown embed via monitor_bridge with a 2-second timeout. Wrap in try/except -- best-effort, accept that forced kills won't produce this.

**In `main_loop()` function:**

1. Add `health_tracker: HealthTracker | None = None` parameter.

2. After the bus fetch block (where `fresh_bus` is evaluated):
   - If `fresh_bus != (None, None)`: call `health_tracker.record_success("bus_api")` (if health_tracker is not None).
   - Else (fetch failed): call `health_tracker.record_failure("bus_api", "Bus API returned no data")` (if health_tracker is not None).

3. After the weather fetch block (where `fresh_weather` is evaluated):
   - If `fresh_weather` is truthy: call `health_tracker.record_success("weather_api")`.
   - Else (fetch failed): call `health_tracker.record_failure("weather_api", "Weather API returned no data")`.

4. After `client.push_frame(frame)`:
   - Call `health_tracker.record_success("device")` (if health_tracker is not None).
   - Wrap `push_frame()` in a try/except that on failure calls `health_tracker.record_failure("device", str(e))` and continues the loop (do NOT crash).

**CRITICAL:** All health_tracker calls must be wrapped in `if health_tracker:` guards. The main loop must work identically when health_tracker is None (monitoring disabled). The `push_frame()` call already has error handling in PixooClient -- the try/except here is an additional safety net for monitoring integration only.

**CRITICAL:** Do NOT modify the bus/weather fetch logic, staleness tracking, animation ticking, or display rendering. Only ADD health_tracker calls alongside existing success/failure branches.
  </action>
  <verify>
    <automated>cd /Users/jdl/Documents/GitHub/divoom-hub && python -m pytest tests/ -v</automated>
    <manual>Verify main.py has health_tracker calls in bus fetch, weather fetch, and push_frame blocks</manual>
  </verify>
  <done>main_loop() calls health_tracker.record_success/record_failure for bus_api, weather_api, and device components. main() creates HealthTracker, wires MonitorBridge via on_ready_callback, sends startup embed, attempts shutdown embed. All existing tests pass.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify monitoring embeds appear in Discord</name>
  <files>n/a</files>
  <action>
Human verification of the complete monitoring integration.

What was built: Complete Discord monitoring integration -- startup embed on launch, error/recovery embeds on API failures, and on-demand status command.

How to verify:
1. Ensure DISCORD_MONITOR_CHANNEL_ID is set in .env (your monitoring channel)
2. Run: `python src/main.py --ip YOUR_PIXOO_IP` (or `--simulated` if no device)
3. Check monitoring Discord channel -- a blue "Divoom Hub Started" embed should appear within 3-5 seconds with config summary (Pixoo IP, bus stops, weather location)
4. Type "status" in the monitoring channel -- a blue status embed should appear showing component statuses and uptime
5. Verify the display-message channel still works as before (send a test message, confirm checkmark reaction)
6. Stop the app with Ctrl+C -- a gray "Divoom Hub Stopped" embed should appear (best-effort)
7. To test error alerts: temporarily set an invalid bus quay ID and restart -- after ~3 minutes (3 failed fetches), a red error embed should appear in the monitoring channel

Resume: Type "approved" or describe issues found.
  </action>
  <verify>Manual human verification -- see action steps above</verify>
  <done>User confirmed: startup embed appears, status command works, display-message channel unchanged, error alerts fire on sustained failures.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- all tests pass (existing + new)
2. `python -c "from src.config import DISCORD_MONITOR_CHANNEL_ID"` -- config imports
3. `grep -n "health_tracker" src/main.py` -- shows integration points
4. `grep -n "monitor_channel_id" src/providers/discord_bot.py` -- shows bot extension
5. Manual: startup embed, status command, display-message channel unchanged
</verification>

<success_criteria>
- Blue startup embed appears in monitoring channel on app launch
- "status" command in monitoring channel returns health snapshot
- Display-message channel behavior is unchanged
- Error embeds appear after sustained API failures (debounced)
- Recovery embeds appear when failed APIs recover
- App runs normally without DISCORD_MONITOR_CHANNEL_ID set
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-discord-status-logging-for-remote-monitoring/11-02-SUMMARY.md`
</output>
