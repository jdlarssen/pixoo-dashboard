---
phase: 11-discord-status-logging-for-remote-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/providers/discord_monitor.py
  - tests/test_discord_monitor.py
autonomous: true
requirements:
  - MON-02
  - MON-03
  - TEST-03

must_haves:
  truths:
    - "HealthTracker debounces failures -- only alerts after N consecutive failures"
    - "HealthTracker emits recovery with downtime duration when a failed component succeeds"
    - "Error embeds include component name, error type, duration, and last success time"
    - "Recovery embeds include component name and downtime duration"
    - "Startup embed includes config summary (Pixoo IP, bus stops, weather location)"
    - "MonitorBridge.send_embed() is thread-safe and non-blocking with timeout"
  artifacts:
    - path: "src/providers/discord_monitor.py"
      provides: "MonitorBridge, HealthTracker, embed builders"
      min_lines: 150
    - path: "tests/test_discord_monitor.py"
      provides: "HealthTracker and embed builder tests"
      min_lines: 80
  key_links:
    - from: "src/providers/discord_monitor.py"
      to: "discord.Embed"
      via: "embed builder functions"
      pattern: "discord\\.Embed"
    - from: "src/providers/discord_monitor.py"
      to: "asyncio.run_coroutine_threadsafe"
      via: "MonitorBridge.send_embed()"
      pattern: "run_coroutine_threadsafe"
---

<objective>
Create the core monitoring module with MonitorBridge (sync-to-async Discord embed sender), HealthTracker (debounced per-component failure/recovery state machine), and color-coded embed builder functions. Include comprehensive tests for HealthTracker logic and embed structure.

Purpose: Isolate all monitoring logic in a testable module before wiring it into the existing bot and main loop. The HealthTracker is the brain -- it decides WHEN to alert and WHAT to include. The MonitorBridge is the voice -- it delivers embeds thread-safely.

Output: `src/providers/discord_monitor.py` and `tests/test_discord_monitor.py`
</objective>

<execution_context>
@/Users/jdl/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-discord-status-logging-for-remote-monitoring/11-CONTEXT.md
@.planning/phases/11-discord-status-logging-for-remote-monitoring/11-RESEARCH.md
@src/providers/discord_bot.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create discord_monitor.py with MonitorBridge, HealthTracker, and embed builders</name>
  <files>src/providers/discord_monitor.py</files>
  <action>
Create `src/providers/discord_monitor.py` with three major components:

**1. Embed color constants and builder functions:**
- `COLORS` dict: `error=0xFF0000`, `recovery=0x00FF00`, `startup=0x3498DB`, `shutdown=0x95A5A6`
- `error_embed(component, error_type, detail, duration_s, last_success_str)` -> `discord.Embed` with red color, fields for Component, Error Type, Failing For, Last Success. Set footer "Divoom Hub Monitor". Set timestamp to `datetime.now(timezone.utc)`.
- `recovery_embed(component, downtime_s)` -> `discord.Embed` with green color, description like "{component} recovered after {minutes:.0f} minutes". Include downtime field.
- `startup_embed(pixoo_ip, bus_quay_dir1, bus_quay_dir2, weather_lat, weather_lon)` -> `discord.Embed` with blue color, title "Divoom Hub Started", fields for Pixoo IP, Bus Stops (both quay IDs), Weather Location (lat, lon).
- `shutdown_embed()` -> `discord.Embed` with gray color, title "Divoom Hub Stopped".
- `status_embed(components_dict, uptime_s)` -> `discord.Embed` with blue color, shows per-component OK/DOWN status and uptime.

**2. MonitorBridge class:**
- `__init__(self, client: discord.Client, channel_id: int)` -- stores client and channel_id. Does NOT access client.loop yet (not available until on_ready).
- `send_embed(self, embed: discord.Embed) -> bool` -- thread-safe, non-blocking. Uses `asyncio.run_coroutine_threadsafe(channel.send(embed=embed), self._client.loop)`. Returns True on success, False on failure. Uses `fut.result(timeout=5.0)` wrapped in try/except. If `client.get_channel()` returns None, log warning and return False. All exceptions caught and logged -- NEVER propagate to caller.
- The class must be safe to call from the synchronous main thread while the Discord bot runs in a daemon thread.

**3. HealthTracker class:**
- Uses `dataclass` `ComponentState` with fields: `name: str`, `first_failure_time: float` (monotonic), `last_alert_time: float` (monotonic), `failure_count: int`, `is_alerting: bool`, `last_success_time: float` (monotonic), `last_success_str: str` (human-readable).
- `__init__(self, monitor: MonitorBridge | None)` -- if monitor is None, tracking still works but no embeds are sent (for when monitoring is disabled).
- Debounce config as class-level dict `DEBOUNCE`: `bus_api` (3 failures / 900s repeat), `weather_api` (2 failures / 1800s repeat), `device` (5 failures / 300s repeat). Default for unknown components: 3 failures / 600s repeat.
- `record_success(self, component: str) -> None` -- if component was alerting (is_alerting=True), send recovery embed with downtime = monotonic() - first_failure_time. Reset failure_count, is_alerting, first_failure_time. Update last_success_time and last_success_str.
- `record_failure(self, component: str, error_info: str) -> None` -- increment failure_count. If failure_count == 1, set first_failure_time. When failure_count reaches debounce threshold AND (not yet alerting OR repeat interval elapsed since last_alert_time), send error embed and set is_alerting=True, update last_alert_time. Duration in embed = monotonic() - first_failure_time.
- `get_status(self) -> dict[str, dict]` -- returns per-component status for the status command. Each entry has: `status` ("ok" or "down"), `failure_count`, `downtime_s` (if down), `last_success` (human string).
- `uptime_s` property tracking time since HealthTracker was created.
- All send_embed calls wrapped in try/except -- monitoring must NEVER crash the caller.

Import discord lazily inside MonitorBridge methods (same pattern as discord_bot.py) to avoid import errors when discord.py is not needed.

Use `time.monotonic()` for all timing. Use `datetime.now(timezone.utc)` for human-readable timestamps. Use `logging.getLogger(__name__)` for all logging.
  </action>
  <verify>
    <automated>cd /Users/jdl/Documents/GitHub/divoom-hub && python -c "from src.providers.discord_monitor import HealthTracker, error_embed, recovery_embed, startup_embed, shutdown_embed, status_embed, MonitorBridge, COLORS; print('Import OK')"</automated>
    <manual>Verify module has MonitorBridge, HealthTracker, and all 5 embed builders</manual>
  </verify>
  <done>discord_monitor.py exists with MonitorBridge (thread-safe send_embed), HealthTracker (debounced failure/recovery state machine), and 5 color-coded embed builder functions. All imports resolve cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create tests for HealthTracker debounce logic and embed builders</name>
  <files>tests/test_discord_monitor.py</files>
  <action>
Create `tests/test_discord_monitor.py` with comprehensive tests:

**TestEmbedBuilders class:**
- `test_error_embed_has_red_color` -- verify color is 0xFF0000
- `test_error_embed_has_required_fields` -- verify Component, Error Type, Failing For, Last Success fields present
- `test_recovery_embed_has_green_color` -- verify color is 0x00FF00
- `test_recovery_embed_includes_downtime` -- verify description mentions duration
- `test_startup_embed_has_blue_color` -- verify color is 0x3498DB
- `test_startup_embed_has_config_fields` -- verify Pixoo IP, Bus Stops, Weather fields present
- `test_shutdown_embed_has_gray_color` -- verify color is 0x95A5A6
- `test_status_embed_shows_component_status` -- verify fields for each component

**TestHealthTracker class** (use monitor=None to avoid Discord dependency):
- `test_single_failure_does_not_alert` -- record 1 failure for bus_api (threshold 3), verify is_alerting is False
- `test_debounce_threshold_triggers_alert` -- record 3 failures for bus_api, verify is_alerting becomes True
- `test_recovery_after_alert_clears_state` -- record 3 failures then 1 success, verify is_alerting is False and failure_count is 0
- `test_success_without_prior_failure_is_noop` -- record_success on component with no failures, verify no crash
- `test_different_components_tracked_independently` -- fail bus_api 3 times, fail weather_api 1 time, verify bus is alerting but weather is not
- `test_get_status_returns_all_components` -- record some successes and failures, verify get_status() dict has correct structure
- `test_uptime_increases` -- create tracker, sleep briefly, verify uptime_s > 0

For debounce threshold testing, mock `time.monotonic()` using `unittest.mock.patch` to control timing precisely. Import HealthTracker and ComponentState. Since monitor=None, no Discord client needed -- HealthTracker tracks state silently.

For embed builder tests, discord.py's `Embed` class works without a running bot -- just import discord and call the builder functions directly. Check `embed.color.value`, `embed.title`, and iterate `embed.fields` to verify field names.
  </action>
  <verify>
    <automated>cd /Users/jdl/Documents/GitHub/divoom-hub && python -m pytest tests/test_discord_monitor.py -v</automated>
  </verify>
  <done>All HealthTracker tests pass: debounce thresholds prevent premature alerting, recovery clears state, components tracked independently. All embed builder tests pass: correct colors, required fields present, config summary in startup embed.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.providers.discord_monitor import HealthTracker, MonitorBridge"` -- imports succeed
2. `python -m pytest tests/test_discord_monitor.py -v` -- all tests pass
3. `python -m pytest tests/ -v` -- no regressions in existing tests
</verification>

<success_criteria>
- discord_monitor.py contains MonitorBridge with thread-safe send_embed()
- discord_monitor.py contains HealthTracker with debounced record_success/record_failure
- 5 embed builder functions create correctly colored Discord embeds with appropriate fields
- HealthTracker tests verify debounce thresholds, recovery behavior, and independent component tracking
- Embed builder tests verify colors and field presence
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-discord-status-logging-for-remote-monitoring/11-01-SUMMARY.md`
</output>
