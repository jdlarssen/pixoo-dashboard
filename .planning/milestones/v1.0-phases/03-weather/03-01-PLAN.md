---
phase: 03-weather
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.py
  - src/providers/weather.py
  - src/display/state.py
  - tests/test_weather_provider.py
autonomous: true
requirements: [WTHR-01, WTHR-03, WTHR-04]

must_haves:
  truths:
    - "Weather provider fetches current temperature, symbol code, high/low, and precipitation data from MET Locationforecast 2.0"
    - "Provider returns None on API failure without crashing the caller"
    - "API calls include proper User-Agent header and respect If-Modified-Since caching"
    - "DisplayState carries weather fields through the dirty flag pattern"
  artifacts:
    - path: "src/providers/weather.py"
      provides: "MET API client with WeatherData dataclass, fetch_weather, fetch_weather_safe"
      exports: ["WeatherData", "fetch_weather", "fetch_weather_safe"]
    - path: "src/config.py"
      provides: "Weather configuration constants (coordinates, refresh interval, API URL, User-Agent)"
      contains: "WEATHER_REFRESH_INTERVAL"
    - path: "src/display/state.py"
      provides: "DisplayState with weather fields"
      contains: "weather_temp"
    - path: "tests/test_weather_provider.py"
      provides: "Unit tests for weather provider"
      min_lines: 60
  key_links:
    - from: "src/providers/weather.py"
      to: "api.met.no/weatherapi/locationforecast/2.0/compact"
      via: "requests.get with User-Agent header"
      pattern: "requests\\.get.*locationforecast"
    - from: "src/display/state.py"
      to: "src/providers/weather.py"
      via: "WeatherData fields mapped to DisplayState weather fields"
      pattern: "weather_temp|weather_symbol"
---

<objective>
Weather data provider: MET Locationforecast 2.0 API client with caching, configuration, and DisplayState extension.

Purpose: Establish the data pipeline from Yr/MET to DisplayState, following the exact provider pattern from the bus phase. This is the data foundation that Plan 02 renders.
Output: Working weather provider that fetches temperature, weather symbol, high/low, and precipitation data. DisplayState extended with weather fields.
</objective>

<execution_context>
@/Users/jdl/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-weather/03-RESEARCH.md
@.planning/phases/03-weather/03-CONTEXT.md
@.planning/phases/02-bus-departures/02-01-SUMMARY.md

@src/providers/bus.py
@src/config.py
@src/display/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Weather configuration and MET API provider</name>
  <files>src/config.py, src/providers/weather.py</files>
  <action>
Add weather configuration constants to `src/config.py`:
- `WEATHER_LAT` = 63.4305 (Trondheim latitude, env-var configurable)
- `WEATHER_LON` = 10.3951 (Trondheim longitude, env-var configurable)
- `WEATHER_REFRESH_INTERVAL` = 600 (10 minutes in seconds -- MET updates every ~10 min)
- `WEATHER_API_URL` = "https://api.met.no/weatherapi/locationforecast/2.0/compact"
- `WEATHER_USER_AGENT` = "divoom-hub/0.1 github.com/jdl/divoom-hub" (env-var configurable)

Create `src/providers/weather.py` following the bus.py provider pattern:

1. **WeatherData dataclass** with fields:
   - `temperature: float` (current temp in Celsius from `instant.details.air_temperature`)
   - `symbol_code: str` (from `next_1_hours.summary.symbol_code`, e.g. "partlycloudy_day")
   - `high_temp: float` (today's high -- scan today's timeseries for max `air_temperature`)
   - `low_temp: float` (today's low -- scan today's timeseries for min `air_temperature`)
   - `precipitation_mm: float` (from `next_1_hours.details.precipitation_amount`, default 0.0)
   - `is_day: bool` (derived: True if symbol_code does NOT contain "_night" or "_polartwilight")

2. **Module-level cache variables:**
   - `_cached_data: dict | None = None` (raw JSON response)
   - `_last_modified: str | None = None` (Last-Modified header for If-Modified-Since)

3. **`fetch_weather(lat, lon) -> WeatherData`** function:
   - GET `WEATHER_API_URL` with params `lat` (4 decimal places) and `lon` (4 decimal places)
   - Headers: `User-Agent: {WEATHER_USER_AGENT}`, plus `If-Modified-Since: {_last_modified}` if cached
   - If 304 Not Modified: parse from `_cached_data`
   - If 200: update `_cached_data` and `_last_modified` from response headers, then parse
   - Parse current conditions from `timeseries[0]`:
     - `air_temperature` from `data.instant.details`
     - `symbol_code` from `data.next_1_hours.summary`
     - `precipitation_amount` from `data.next_1_hours.details`
   - Parse today's high/low by scanning timeseries entries whose `time` starts with today's date (ISO format `YYYY-MM-DD`):
     - Collect all `instant.details.air_temperature` values
     - high = max(temps), low = min(temps)
     - Fallback if no today entries: use `next_6_hours.details.air_temperature_max/min` from first entry
   - Return WeatherData

4. **`fetch_weather_safe(lat, lon) -> WeatherData | None`** function:
   - Wraps `fetch_weather()` in try/except
   - Logs exception, returns None on failure
   - Matches bus.py `fetch_departures_safe()` pattern exactly

Timeout: 10 seconds on API request (same as bus provider).
  </action>
  <verify>
Run `python -c "from src.providers.weather import fetch_weather_safe; print(fetch_weather_safe(63.4305, 10.3951))"` and confirm it returns a WeatherData object with real temperature data (or None if network unavailable).
Verify `src/config.py` has all WEATHER_* constants.
  </verify>
  <done>
Weather provider fetches live data from MET API with proper User-Agent, If-Modified-Since caching, today's high/low calculation, and error-safe wrapper. Configuration constants defined and env-var configurable.
  </done>
</task>

<task type="auto">
  <name>Task 2: DisplayState weather extension and provider tests</name>
  <files>src/display/state.py, tests/test_weather_provider.py</files>
  <action>
**Extend DisplayState** in `src/display/state.py`:
- Add fields (all optional, defaulting to None/True):
  - `weather_temp: int | None = None` (rounded to nearest int for display)
  - `weather_symbol: str | None = None` (MET symbol_code string)
  - `weather_high: int | None = None` (today's high, rounded)
  - `weather_low: int | None = None` (today's low, rounded)
  - `weather_precip_mm: float | None = None` (next 1h precipitation in mm)
  - `weather_is_day: bool = True` (day/night from symbol_code)
- Update `from_now()` classmethod to accept optional `weather_data: WeatherData | None = None` parameter:
  - If weather_data is not None: populate weather fields (round temps to int)
  - If weather_data is None: leave defaults (None/True)
- Import WeatherData from providers.weather (use TYPE_CHECKING to avoid circular imports if needed)

**Create tests** in `tests/test_weather_provider.py`:
- Test `parse_current()` or equivalent with mock timeseries data (mock the JSON structure from MET API)
- Test high/low calculation with multiple timeseries entries for "today"
- Test high/low fallback when no today entries exist
- Test `is_day` derivation from symbol_code variants ("clearsky_day" -> True, "rain_night" -> False, "rain" -> True)
- Test `fetch_weather_safe()` returns None on network error (mock requests.get to raise)
- Test If-Modified-Since caching (304 response returns cached data)
- Test DisplayState with weather fields preserves equality for dirty flag
- Test DisplayState.from_now() with WeatherData populates all fields correctly
- Target: 12+ tests covering parsing, caching, error handling, and DisplayState integration
  </action>
  <verify>
Run `cd /Users/jdl/Documents/GitHub/divoom-hub && python -m pytest tests/test_weather_provider.py -v` -- all tests pass.
Run `cd /Users/jdl/Documents/GitHub/divoom-hub && python -m pytest tests/ -v` -- all existing tests still pass (no regressions).
  </verify>
  <done>
DisplayState carries weather data through the dirty flag pattern (fields use int/float/str/bool for hashable equality). Weather provider has 12+ unit tests covering API parsing, caching, error handling, and state integration.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/ -v` -- all tests pass (existing + new weather tests)
- `python -c "from src.providers.weather import WeatherData, fetch_weather_safe"` -- imports work
- `python -c "from src.display.state import DisplayState; s = DisplayState.from_now(__import__('datetime').datetime.now()); print(s.weather_temp)"` -- prints None (no weather data provided)
- Weather config constants accessible: `python -c "from src.config import WEATHER_REFRESH_INTERVAL; print(WEATHER_REFRESH_INTERVAL)"` -- prints 600
</verification>

<success_criteria>
- Weather provider fetches real data from MET API with proper User-Agent and caching
- fetch_weather_safe() returns WeatherData on success, None on failure
- DisplayState includes weather fields without breaking existing bus/clock equality
- 12+ new tests pass for weather provider
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/03-weather/03-01-SUMMARY.md`
</output>
