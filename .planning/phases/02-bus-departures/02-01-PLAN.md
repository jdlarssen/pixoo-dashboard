---
phase: 02-bus-departures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.py
  - src/providers/bus.py
  - src/display/state.py
  - tests/test_bus_provider.py
autonomous: true
requirements: [BUS-01, BUS-02, BUS-03, BUS-05]

must_haves:
  truths:
    - "Entur JourneyPlanner v3 API returns real-time departure data for two quay IDs"
    - "Countdown minutes are correctly calculated from ISO 8601 expectedDepartureTime"
    - "Bus config (quay IDs, refresh interval, client name) is configurable via environment variables"
    - "DisplayState carries bus departure data for both directions"
  artifacts:
    - path: "src/providers/bus.py"
      provides: "Entur API client with fetch_departures() and safe wrapper"
      contains: "fetch_departures"
    - path: "src/config.py"
      provides: "Bus configuration constants with env var overrides"
      contains: "BUS_QUAY"
    - path: "src/display/state.py"
      provides: "DisplayState with bus_direction1 and bus_direction2 fields"
      contains: "bus_direction1"
    - path: "tests/test_bus_provider.py"
      provides: "Tests for countdown calculation and response parsing"
      contains: "test_"
  key_links:
    - from: "src/providers/bus.py"
      to: "https://api.entur.io/journey-planner/v3/graphql"
      via: "requests.post with ET-Client-Name header"
      pattern: "requests\\.post.*entur"
    - from: "src/providers/bus.py"
      to: "src/config.py"
      via: "imports quay IDs and client name"
      pattern: "from src\\.config import"
    - from: "src/display/state.py"
      to: "src/providers/bus.py"
      via: "DisplayState.from_now accepts bus data tuple"
      pattern: "bus_direction"
---

<objective>
Create the bus departure data provider that queries the Entur JourneyPlanner v3 GraphQL API for real-time departures from two quay IDs (one per direction at Ladeveien), calculates countdown minutes, and extends DisplayState to carry bus data.

Purpose: Establishes the data pipeline for bus departures -- the provider fetches, parses, and returns structured departure data that the renderer (Plan 02) will draw in the bus zone.

Output: Working bus provider module, extended config with bus settings, extended DisplayState with bus fields, and tests verifying countdown math and response parsing.
</objective>

<execution_context>
@/Users/jdl/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bus-departures/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

Key existing files:
@src/config.py
@src/display/state.py
@src/providers/clock.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Quay ID lookup and bus configuration</name>
  <files>src/config.py</files>
  <action>
First, look up the quay IDs for Ladeveien (NSR:StopPlace:42686) by running a one-time GraphQL query against the Entur API. Use this query via curl or a temporary Python script:

```python
import requests
query = '''
{
  stopPlace(id: "NSR:StopPlace:42686") {
    name
    quays {
      id
      name
      publicCode
      estimatedCalls(numberOfDepartures: 1) {
        destinationDisplay {
          frontText
        }
      }
    }
  }
}
'''
resp = requests.post(
    "https://api.entur.io/journey-planner/v3/graphql",
    json={"query": query},
    headers={"ET-Client-Name": "jdl-divoomhub"},
    timeout=10,
)
import json
print(json.dumps(resp.json(), indent=2))
```

From the response, identify which quay ID maps to direction 1 (Sentrum) and which to direction 2 (Lade) by looking at the `frontText` destination. Record both NSR:Quay:XXXXX IDs.

Then extend `src/config.py` with bus-specific configuration:
- `BUS_QUAY_DIRECTION1`: env var `BUS_QUAY_DIR1` with default set to the discovered Sentrum quay ID
- `BUS_QUAY_DIRECTION2`: env var `BUS_QUAY_DIR2` with default set to the discovered Lade quay ID
- `BUS_REFRESH_INTERVAL = 60` (seconds)
- `BUS_NUM_DEPARTURES = 2`
- `ET_CLIENT_NAME`: env var `ET_CLIENT_NAME` with default `"jdl-divoomhub"`
- `ENTUR_API_URL = "https://api.entur.io/journey-planner/v3/graphql"`

Follow the existing pattern in config.py: `os.environ.get()` with sensible defaults.
  </action>
  <verify>Run `python -c "from src.config import BUS_QUAY_DIRECTION1, BUS_QUAY_DIRECTION2, BUS_REFRESH_INTERVAL; print(BUS_QUAY_DIRECTION1, BUS_QUAY_DIRECTION2, BUS_REFRESH_INTERVAL)"` -- should print two NSR:Quay:XXXXX IDs and 60.</verify>
  <done>Config module exports bus quay IDs (real IDs from Entur lookup), refresh interval, num departures, client name, and API URL. All configurable via environment variables.</done>
</task>

<task type="auto">
  <name>Task 2: Bus departure provider and DisplayState extension</name>
  <files>src/providers/bus.py, src/display/state.py, tests/test_bus_provider.py</files>
  <action>
Create `src/providers/bus.py` implementing the Entur API client:

1. **GraphQL query string** -- Use the quay-level query from research:
   ```
   { quay(id: "%s") { id name estimatedCalls(numberOfDepartures: %d, omitNonBoarding: true, timeRange: 3600) { expectedDepartureTime aimedDepartureTime realtime destinationDisplay { frontText } serviceJourney { line { publicCode } } } } }
   ```

2. **BusDeparture dataclass** with fields: `minutes: int`, `is_realtime: bool`, `destination: str`, `line: str`

3. **`fetch_departures(quay_id: str, num_departures: int = 2) -> list[BusDeparture]`** function:
   - Import config values from `src.config` (ENTUR_API_URL, ET_CLIENT_NAME)
   - POST the GraphQL query via `requests.post(url, json={"query": query}, headers={"ET-Client-Name": ...}, timeout=10)`
   - Call `response.raise_for_status()`
   - Parse `data["data"]["quay"]["estimatedCalls"]`
   - For each call: parse `expectedDepartureTime` via `datetime.fromisoformat()`, calculate countdown as `int((dep_time - datetime.now(tz=timezone.utc)).total_seconds() / 60)`, clamp to `max(0, minutes)`
   - Return list of BusDeparture objects

4. **`fetch_departures_safe(quay_id: str, num_departures: int = 2) -> list[int] | None`** wrapper:
   - Try/except around `fetch_departures()`
   - On success: return `[d.minutes for d in departures]`
   - On any exception: log via `logger.exception(...)` and return `None`

5. **`fetch_bus_data() -> tuple[list[int] | None, list[int] | None]`** convenience function:
   - Import BUS_QUAY_DIRECTION1, BUS_QUAY_DIRECTION2, BUS_NUM_DEPARTURES from config
   - Call `fetch_departures_safe()` for each direction
   - Return tuple of (direction1_minutes, direction2_minutes)

Then extend `src/display/state.py`:
- Add two optional fields to DisplayState: `bus_direction1: tuple[int, ...] | None = None` and `bus_direction2: tuple[int, ...] | None = None`
- Use tuples (not lists) so DisplayState remains hashable/comparable for the dirty flag pattern
- Update `from_now()` to accept an optional `bus_data` parameter: `bus_data: tuple[list[int] | None, list[int] | None] = (None, None)`
- In `from_now()`, convert the lists to tuples: `bus_direction1=tuple(bus_data[0]) if bus_data[0] else None`

IMPORTANT: Use `datetime.now(tz=timezone.utc)` for countdown calculation (Pitfall 1 from research -- timezone-naive comparison causes TypeError).

Create `tests/test_bus_provider.py`:
- Test `parse_countdown_minutes` logic: mock a fixed "now" and verify countdown calculation
- Test that negative countdowns are clamped to 0
- Test that empty estimatedCalls returns empty list
- Test `fetch_departures_safe` returns None on exception (mock requests to raise)
- Test DisplayState equality with bus data (two states with same bus data are equal, different bus data are not equal)

Use `unittest.mock.patch` to mock `requests.post` and `datetime.now` in tests. Do NOT make real API calls in tests.
  </action>
  <verify>Run `python -m pytest tests/test_bus_provider.py -v` -- all tests pass. Run `python -c "from src.providers.bus import fetch_bus_data; print('import OK')"` -- no import errors. Run `python -c "from src.display.state import DisplayState; s = DisplayState(time_str='14:00', date_str='tor 20. feb', bus_direction1=(5, 12), bus_direction2=(3, 8)); print(s)"` -- prints state with bus data.</verify>
  <done>Bus provider fetches real-time departures from Entur API, calculates countdown minutes, handles errors gracefully. DisplayState carries bus data as optional tuple fields. All tests pass with mocked API responses.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- all tests pass (existing + new bus provider tests)
2. `python -c "from src.providers.bus import fetch_bus_data; print(fetch_bus_data())"` -- returns tuple of two lists (or None if API is down), does not crash
3. `python -c "from src.display.state import DisplayState; s1 = DisplayState('14:00', 'tor 20. feb', (5,12), (3,8)); s2 = DisplayState('14:00', 'tor 20. feb', (5,12), (3,8)); print(s1 == s2)"` -- prints True
4. `ruff check src/providers/bus.py src/config.py src/display/state.py` -- no lint errors
</verification>

<success_criteria>
- Bus provider module exists and can fetch real departure data from Entur API
- Config has real quay IDs for Ladeveien (looked up from Entur, not placeholder XXX)
- Countdown math handles timezone-aware datetimes correctly
- Errors are caught and logged, never crash the caller
- DisplayState carries bus data and dirty flag pattern still works
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-bus-departures/02-01-SUMMARY.md`
</output>
