---
phase: 03-weather
plan: 03
type: execute
wave: 1
depends_on: ["03-02"]
files_modified:
  - src/display/renderer.py
  - src/display/weather_anim.py
  - src/device/pixoo_client.py
  - src/main.py
  - tests/test_renderer.py
  - tests/test_weather_anim.py
autonomous: true
requirements: [WTHR-02]
gap_closure: true

must_haves:
  truths:
    - "Weather animation is visibly distinguishable from a static black background on the Pixoo 64"
    - "Animation frames reach the device at a consistent rate without silent drops"
    - "Weather text (temperature, high/low, rain) remains readable over animated backgrounds"
  artifacts:
    - path: "src/display/renderer.py"
      provides: "Single-pass alpha compositing (no double alpha)"
      contains: "alpha_composite"
    - path: "src/display/weather_anim.py"
      provides: "LED-visible alpha values and multi-pixel particles"
    - path: "src/device/pixoo_client.py"
      provides: "Rate limiter aligned with animation loop speed"
    - path: "src/main.py"
      provides: "Animation loop rate matching device push rate"
    - path: "tests/test_weather_anim.py"
      provides: "Tests verifying animation alpha values and pixel coverage"
  key_links:
    - from: "src/main.py"
      to: "src/device/pixoo_client.py"
      via: "sleep_time matches rate limiter interval"
      pattern: "sleep_time.*=.*0\\."
    - from: "src/display/renderer.py"
      to: "weather_anim frame"
      via: "alpha_composite applied once only"
      pattern: "alpha_composite"
---

<objective>
Fix weather animation visibility on the Pixoo 64 LED display.

Purpose: UAT test 4 failed -- user reported "I don't see it, it might be too subtle." Debug session identified three compounding root causes: (1) double alpha application in compositing squashes effective opacity from ~20% to ~4%, (2) device rate limiter silently drops 75% of animation frames, and (3) alpha values and particle sizes are too conservative for LED hardware. All three must be fixed together for animation to be visible.

Output: Visible weather animation on the Pixoo 64 that matches conditions (rain, snow, clouds, etc.) without obscuring temperature text.
</objective>

<execution_context>
@/Users/jdl/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jdl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/weather-animation-too-subtle.md
@.planning/phases/03-weather/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix compositing, rate limiter, and animation loop alignment</name>
  <files>
    src/display/renderer.py
    src/device/pixoo_client.py
    src/main.py
  </files>
  <action>
Fix three interconnected issues that compound to make animation invisible:

**1. renderer.py (lines 128-137) -- Fix double alpha compositing:**

Replace the current compositing block in `render_weather_zone()`:
```python
# CURRENT (broken -- applies alpha twice):
img.paste(
    Image.alpha_composite(
        Image.new("RGBA", anim_frame.size, (0, 0, 0, 255)),
        anim_frame,
    ).convert("RGB"),
    (0, zone_y),
    mask=anim_frame.split()[3],
)
```

With a single-pass alpha composite approach:
```python
# Convert the region of img under the weather zone to RGBA
zone_region = img.crop((0, zone_y, anim_frame.width, zone_y + anim_frame.height)).convert("RGBA")
# Alpha-composite the animation frame onto the zone region (single alpha application)
composited = Image.alpha_composite(zone_region, anim_frame)
# Paste the result back as RGB
img.paste(composited.convert("RGB"), (0, zone_y))
```

This applies the animation's alpha channel exactly ONCE via `alpha_composite`, instead of squaring it through `alpha_composite` + `paste(mask=alpha)`.

**2. pixoo_client.py (lines 62-66) -- Lower rate limit to allow animation frames through:**

Change the minimum push interval from 1.0 seconds to 0.3 seconds. The Pixoo 64 hardware can handle ~3 FPS over the HTTP API without lockup. The 1-second limit was overly conservative and causes 75% of 4-FPS frames to be silently dropped.

Change:
```python
if self._last_push_time > 0 and elapsed < 1.0:
```
To:
```python
if self._last_push_time > 0 and elapsed < 0.3:
```

Also update the log message and docstring to reflect the new 0.3s (300ms) minimum interval.

**3. main.py (line 153) -- Align sleep time with new rate limit:**

Change the animation sleep time from 0.25s to 0.35s so it slightly exceeds the 0.3s rate limit (preventing any frame drops from timing jitter). This gives ~2.8 FPS which is smooth enough for particle animation on a 64px LED display.

Change:
```python
sleep_time = 0.25 if weather_anim is not None else 1.0
```
To:
```python
sleep_time = 0.35 if weather_anim is not None else 1.0
```

Also update the docstring comment in `main_loop()` that references "4 FPS (0.25s sleep)" to say "~3 FPS (0.35s sleep)".
  </action>
  <verify>
Run `python3 -m pytest tests/test_renderer.py -v` -- all existing renderer tests must still pass (especially `test_render_frame_accepts_anim_frame`). Additionally, run a quick pixel-value sanity check: render a frame with a solid alpha-50 animation overlay and verify the weather zone pixels are NOT near-black (they should have channel values > 15, not the ~3-6 range from the double-alpha bug).
  </verify>
  <done>
Compositing applies alpha exactly once (no paste mask). Rate limiter allows ~3 FPS. Animation loop sleeps 0.35s. All 82 existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Increase animation alpha values and particle sizes for LED visibility</name>
  <files>
    src/display/weather_anim.py
    tests/test_weather_anim.py
  </files>
  <action>
Tune all animation parameters in `weather_anim.py` for visibility on LED hardware. Even with the compositing fix, the current alpha values (30-50) are too dim for the Pixoo 64's LED matrix where channel values below ~15 produce no visible light.

**Alpha value changes (all animation classes):**

| Animation | Current Alpha | New Alpha | Rationale |
|-----------|--------------|-----------|-----------|
| RainAnimation | 50 | 120 | Rain drops must be visible as they fall |
| SnowAnimation | 45 | 110 | White on black needs less alpha than colored |
| CloudAnimation (primary) | 35 | 80 | Large ellipses -- moderate alpha for coverage |
| CloudAnimation (secondary) | 30 | 65 | Layered -- slightly less than primary |
| SunAnimation | 15-35 | 50-90 | Pulsing glow should oscillate noticeably |
| ThunderAnimation flash | 40 | 150 | Lightning should be a visible flash |
| FogAnimation | 30-45 | 70-100 | Fog bands should be clearly visible |

**Particle size changes:**

- **RainAnimation:** Change `draw.point()` to `draw.line()` drawing a 2-pixel vertical streak per drop: `draw.line([(x, y), (x, y+1)], fill=(..., 120))`. This creates a 1x2 raindrop instead of a 1x1 point. Also increase drop count from 18 to 22.

- **SnowAnimation:** Change `draw.point()` to `draw.rectangle()` drawing a 2x1 pixel rectangle: `draw.rectangle([x, y, x+1, y], fill=(..., 110))`. This doubles the snowflake width. Keep count at 15 (snow is sparser than rain).

- **ThunderAnimation:** Increase flash alpha from 40 to 150. The flash is already a full-zone rectangle so size is fine, but it needs to actually flash visibly.

- **SunAnimation:** Update the alpha oscillation range from `15 + 20 * ...` to `50 + 40 * ...` (oscillates between 50 and 90).

- **CloudAnimation, FogAnimation:** Only alpha changes needed (shapes are already appropriately sized).

**Movement per tick adjustments for ~3 FPS:**

Since the frame rate changes from ~1 effective FPS (due to old rate limiter dropping frames) to ~3 FPS, reduce movement per tick to maintain similar visual speed:

- RainAnimation: Change `drop[1] += random.randint(2, 3)` to `drop[1] += random.randint(1, 2)` (slower per-tick since more ticks per second now)
- SnowAnimation: Keep at `random.randint(1, 2)` (already slow enough)
- CloudAnimation: Change speeds from `[0.3, 0.2, 0.4]` to `[0.15, 0.1, 0.2]` (halved for ~3x frame rate)
- FogAnimation: Change `self._offset += 0.15` to `self._offset += 0.08`

**Create tests in `tests/test_weather_anim.py`:**

```python
"""Tests for weather animation visibility on LED hardware."""
from PIL import Image
from src.display.weather_anim import (
    RainAnimation, SnowAnimation, CloudAnimation, SunAnimation,
    ThunderAnimation, FogAnimation, get_animation,
)

class TestAnimationVisibility:
    """Verify animation frames produce LED-visible pixel values."""

    def _max_alpha_in_frame(self, frame: Image.Image) -> int:
        """Return the maximum alpha value found in an RGBA frame."""
        alpha_band = frame.split()[3]
        return max(alpha_band.getdata())

    def _count_non_transparent_pixels(self, frame: Image.Image) -> int:
        """Count pixels with alpha > 0."""
        alpha_band = frame.split()[3]
        return sum(1 for a in alpha_band.getdata() if a > 0)

    def test_rain_alpha_above_minimum(self):
        anim = RainAnimation()
        frame = anim.tick()
        max_a = self._max_alpha_in_frame(frame)
        assert max_a >= 100, f"Rain max alpha {max_a} too low for LED visibility"

    def test_snow_alpha_above_minimum(self):
        anim = SnowAnimation()
        frame = anim.tick()
        max_a = self._max_alpha_in_frame(frame)
        assert max_a >= 90, f"Snow max alpha {max_a} too low for LED visibility"

    def test_cloud_alpha_above_minimum(self):
        anim = CloudAnimation()
        frame = anim.tick()
        max_a = self._max_alpha_in_frame(frame)
        assert max_a >= 60, f"Cloud max alpha {max_a} too low for LED visibility"

    def test_sun_alpha_above_minimum(self):
        anim = SunAnimation()
        frame = anim.tick()
        max_a = self._max_alpha_in_frame(frame)
        assert max_a >= 40, f"Sun max alpha {max_a} too low for LED visibility"

    def test_thunder_flash_alpha(self):
        anim = ThunderAnimation()
        # Tick to the flash frame (tick 20)
        for _ in range(20):
            frame = anim.tick()
        max_a = self._max_alpha_in_frame(frame)
        assert max_a >= 120, f"Thunder flash alpha {max_a} too low"

    def test_fog_alpha_above_minimum(self):
        anim = FogAnimation()
        frame = anim.tick()
        max_a = self._max_alpha_in_frame(frame)
        assert max_a >= 60, f"Fog max alpha {max_a} too low for LED visibility"

    def test_rain_has_multi_pixel_particles(self):
        """Rain drops should be larger than single pixels."""
        anim = RainAnimation()
        frame = anim.tick()
        non_transparent = self._count_non_transparent_pixels(frame)
        # 22 drops * at least 2 pixels each = at least 40
        assert non_transparent >= 40, (
            f"Rain only has {non_transparent} non-transparent pixels -- particles too small"
        )

    def test_snow_has_multi_pixel_particles(self):
        """Snow flakes should be larger than single pixels."""
        anim = SnowAnimation()
        frame = anim.tick()
        non_transparent = self._count_non_transparent_pixels(frame)
        # 15 flakes * at least 2 pixels each = at least 28
        assert non_transparent >= 28, (
            f"Snow only has {non_transparent} non-transparent pixels -- particles too small"
        )

    def test_all_frames_are_rgba_64x20(self):
        """All animation frames must be 64x20 RGBA."""
        for name in ["clear", "rain", "snow", "cloudy", "thunder", "fog"]:
            anim = get_animation(name)
            frame = anim.tick()
            assert frame.size == (64, 20), f"{name} frame size {frame.size} != (64, 20)"
            assert frame.mode == "RGBA", f"{name} frame mode {frame.mode} != RGBA"

    def test_get_animation_returns_correct_types(self):
        assert isinstance(get_animation("rain"), RainAnimation)
        assert isinstance(get_animation("snow"), SnowAnimation)
        assert isinstance(get_animation("cloudy"), CloudAnimation)
        assert isinstance(get_animation("fog"), FogAnimation)
```

These tests enforce the minimum alpha and pixel-coverage thresholds that guarantee LED visibility. They serve as a regression gate so animation cannot be accidentally dimmed below visibility again.
  </action>
  <verify>
Run `python3 -m pytest tests/test_weather_anim.py tests/test_renderer.py -v` -- all tests pass. Verify that rain/snow animation frames contain at least 2 non-transparent pixels per particle by running the pixel-count assertions.
  </verify>
  <done>
All animation alphas are in the 65-150 range (up from 15-50). Rain uses 1x2 streaks, snow uses 2x1 rectangles. Movement speeds halved to compensate for ~3x frame rate. New test file `tests/test_weather_anim.py` enforces minimum alpha and particle size thresholds. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python3 -m pytest -v` -- all tests pass (original 82 + new animation tests)
2. Visual check: Run `python3 src/main.py --simulated --save-frame` and inspect `debug_frame.png` -- weather zone should show visible colored pixels from animation overlay (not pure black)
3. Pixel value sanity: A rain animation frame composited over a black weather zone should produce pixel values with at least one channel > 20 (not the RGB(3,6,10) from the double-alpha bug)
</verification>

<success_criteria>
- Compositing applies alpha exactly once (alpha_composite without paste mask)
- Rate limiter allows animation frames through at ~3 FPS (0.3s interval)
- Main loop sleep matches rate limiter (0.35s)
- All animation alpha values are in 65-150 range
- Rain and snow particles are multi-pixel (2+ pixels each)
- Animation movement speeds adjusted for new frame rate
- All tests pass (existing + new)
- Weather text (temperature, high/low, rain) remains readable over animation
</success_criteria>

<output>
After completion, create `.planning/phases/03-weather/03-03-SUMMARY.md`
</output>
